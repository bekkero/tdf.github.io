<!DOCTYPE html>
<meta charset="utf-8">
<title>History Of Country performance at the Tour De France</title>

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v5.js"></script>

<body>
    <header>
      <h1 itemprop="headline">History of Country Performances at the Tour de France<h1>
    </header>
  

 <h2>History of the Tour de France </h2>
    
                        <p>Tour de France began in 1903 as a strategy to boost the sales of the newspaper L'Auto that was nearly pushed out of business by Le Vélo. The race proved a success and the organizers made it an annual competition. The only time the race was not held was between 1915-1918 and 1940-1946 because of the First and Second World Wars respectively. Between 1903 and 1967, the race ended at Parc des Princes while from 1968 to 1974, it ended at Piste Municipale. From 1975 to present, the race has ended at the Champs-Élysées. Maurice Garin won the first and second series of the Tour de France but was stripped his second win for cheating.<br> </p>
        
                            
                
                                        <h2>Tour de France Records<br> </h2>
        
        
                
                                        <h3>Wins by Country </h3>
        
        
                
                                        <p>France has the largest number of Tour de France titles. Twenty-three French cyclists have won the title 36 times. France won the inaugural race in 1903 and held the winning title for another 5 years until Luxembourg managed to take the win in 1909. France took the title back in 1910 and 1911 before Belgium began to lead the race with wins in 1912-1914 and 1919-1922. France won again in 1923, from 1930-1934, 1937, 1947, 1953-1957, 1961-1964, 1966-1967, 1975, and 1981-1985. France also leads in number of stage wins with 702. France has the most winning streaks (8) and has the second-longest winning streak with 6 consecutive wins from 1903-1908. Interestingly, France has not won the Tour de France since 1985. <br> </p>
        

<button type="button" onClick=run_animation()>Run Animation!</button>


<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>


<script>

function get_number_of_wins_up_to_date (up_to_date_obj_,country_,data_) {
  counter = 0;

  for (var i = 0; i < data_.length; i++) {
    var date_obj = toDateObj(data_[i].Date);
    var country = data_[i].Winner_Country;   
    if(country == country_ &&  date_obj.getTime() <= up_to_date_obj_.getTime()){
      counter = counter + 1;
    }
  }
  return counter;
}

function get_unique_countries(data_) {
  unique = [];
  for (var i = 0; i < data_.length; i++) {
    if( !unique.includes(data_[i].Winner_Country)) {
      unique.push(data_[i].Winner_Country);
    }
  }
  return unique;
}


function get_unique_stage_types(data_) {
  unique = [];
  for (var i = 0; i < data_.length; i++) {
    if( !unique.includes(data_[i].Type)) {
      unique.push(data_[i].Type);
    }
  }
  return unique;
}


function toDateObj(date_str){
  let parts = date_str.split('-');
  let mydate = new Date(parts[0], parts[1] - 1, parts[2]); 
  return mydate;
}


var data;
var country_win_map;
var country_stage_type_to_win_map;
var all_possible_dates;
var animation_runs = 0;

function parse_data() {
    console.log(data);
    country_win_map = new Map();
    var all_possible_countries = get_unique_countries(data);
    all_possible_dates = data.map(function(d) { return toDateObj(d.Date); });
    all_possible_dates.sort(function(a,b){return a - b;});
  
    let k = 0;
    while( k < all_possible_dates.length) {
      let start_date = all_possible_dates[k];
     
      let innel_array = new Map();
      for (let i = 0; i < all_possible_countries.length; i++) {
        country = all_possible_countries[i];
        let number_of_wins_up_to_date = get_number_of_wins_up_to_date (start_date,country,data);
        innel_array.set(country,number_of_wins_up_to_date);
      }
      country_win_map.set(start_date.getTime(),innel_array);
      k = k+1;
    }
}

function setUpAxisAndBars(height, width,svg) {

  // X axis
    var x = d3.scaleBand()
    .range([ 0, width ])
    .domain(data.map(function(d) { return d.Winner_Country; }))
    .padding(0.2);

    svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x))
    .selectAll("text")
      .attr("transform", "translate(-10,0)rotate(-45)")
      .style("text-anchor", "end");

    // Add Y axis
    var y = d3.scaleLinear()
      .domain([0, 100])
      .range([ height, 0]);
    svg.append("g")
      .call(d3.axisLeft(y));

    // Bars
    svg.selectAll("mybar")
      .data(data)
      .enter()
      .append("rect")
        .attr("x", function(d) { return x(d.Winner_Country); })
        .attr("width", x.bandwidth())
        .attr("fill", "#69b3a2")
        // no bar at the beginning thus:
        .attr("height", function(d) { return height - y(0); }) // always equal to 0
        .attr("y", function(d) { return y(0); })
    return [x,y];
}

function aggregateWinsPerStageType( data ){
  var countByCountry;
  data.forEach(function(d){
	    //group and organize your data as needed here
      countByCountry = d3.nest()
      //set the decade as your key
      .key(function(d) {return d["Winner_Country"];})
      .key(function(d) {return d["Type"];})
      //rollup and sum your cat values by decade
      .rollup(d => d.length)
      .entries(data);
    });
  return countByCountry;
}

function get_stage_wins_per_country(country_stage_type_to_win_map,country) {
  returnItem = null;
  let i = 0;
  while( i < country_stage_type_to_win_map.length) {
      console.log( country_stage_type_to_win_map[i]["key"] );
      if ( country_stage_type_to_win_map[i]["key"] == country) {
        returnItem = country_stage_type_to_win_map[i]["values"];
        break;
    }
      i = i+1;
  }
  return returnItem;
}


function animate(x,y,my_p,svg,height,tooltip) {
    let j = 0;

      /*var tooltip = d3.select("#my_dataviz")
      .append("div")
      .style("opacity", 0)
      .attr("class", "tooltip")
      .style("background-color", "white")
      .style("border", "solid")
      .style("border-width", "1px")
      .style("border-radius", "5px")
      .style("padding", "10px")*/

    while( j < all_possible_dates.length) {
      let as_of = all_possible_dates[j];
      
      my_p
      .transition()
      .ease(d3.easeLinear)
      .duration(1000)
      .text(as_of.getFullYear())
      .delay(function(d,i){
            return(j*100)
            });

      let day_data = country_win_map.get(as_of.getTime());
      if (typeof day_data != 'undefined') {           
             var mouseover = function(d) {
              total_number_of_wins = "";
              
              innerHTMLString  = "Country: {d.Winner_Country} <br> Total Number Of Wins: {total_number_of_wins}";             
              string_to_add = ""
              stage_wins_per_country = get_stage_wins_per_country(country_stage_type_to_win_map,d.Winner_Country)
              console.log(stage_wins_per_country);
              if (typeof day_data != 'undefined') {
                let day_country_count = day_data.get(d.Winner_Country);
                if (typeof day_country_count != 'undefined' && day_country_count != 0) {
                  
                  let i = 0;
                  while ( i < stage_wins_per_country.length ) {
                    let k = stage_wins_per_country[i]["key"];
                    let v = stage_wins_per_country[i]["value"];
                    string_to_add = string_to_add + "<br>" + k + ":" + v;
                    i = i+1;
                  }                  
                  total_number_of_wins = day_country_count; 
                } 
              }
              innerHTMLString = innerHTMLString.replace("{d.Winner_Country}",d.Winner_Country);
              innerHTMLString = innerHTMLString.replace("{total_number_of_wins}",total_number_of_wins);
              
              innerHTMLString = innerHTMLString + string_to_add;
                  
              tooltip
                    .html(innerHTMLString)
                    .style("opacity", 1)
              }

               var mousemove = function(d) {
                  tooltip
                    .style("left", (d3.mouse(this)[0]+90) + "px")
                    .style("top", (d3.mouse(this)[1]) + "px")
                }
                var mouseleave = function(d) {
                  tooltip
                    .style("opacity", 0)

                }
        svg.selectAll("rect")
          .on("mouseover", mouseover)
          .on("mousemove", mousemove)
          .on("mouseleave", mouseleave)
          .transition()
          .ease(d3.easeLinear)
          .duration(1000)
          .attr("y", function(d) {
            //let day_data = country_win_map.get(as_of.getTime());   
            if (typeof day_data != 'undefined') {
              let day_country_count = day_data.get(d.Winner_Country);
              if (typeof day_country_count != 'undefined' && day_country_count != 0) {
              // console.log("asof="+as_of+ " country " + d.Winner_Country + " wins=" + day_country_count);
                return y(day_country_count); 
              }else return y(0);
          }else return y(0); 
          })
          .attr("height", function(d) { 
            //let as_of = new Date(d.Date);
            //let day_data = country_win_map.get(as_of.getTime());
            if (typeof day_data != 'undefined') {
              let day_country_count = day_data.get(d.Winner_Country);
              if (typeof day_country_count != 'undefined' && day_country_count != 0) {
                return height - y(day_country_count); 
              } 
              else 
              { return height - y(0); }
            }else{return height - y(0); }  
          })
          .delay(function(d,i){
            return(j*100)
            })

      }
      j = j + 1;
    }

}
var svg;
var my_p;
var tooltip;
function run_animation() {
   
  // set the dimensions and margins of the graph
  var margin = {top: 10, right: 30, bottom: 90, left: 40},
      width = 660 - margin.left - margin.right,
      height = 650 - margin.top - margin.bottom;

  // append the svg object to the body of the page

  if( animation_runs == 0 ) { 

    my_p = d3.select("#my_dataviz")
    .append("p")
    .attr("id", "updateable_p")
    .append("text")
    .text("Loading data for the animation....");

    
    svg = d3.select("#my_dataviz")
      .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")");  
    
    tooltip = d3.select("#my_dataviz")
      .append("div")
      .style("opacity", 0)
      .attr("class", "tooltip")
      .style("background-color", "white")
      .style("border", "solid")
      .style("border-width", "1px")
      .style("border-radius", "5px")
      .style("padding", "10px")

    // Parse the Data
    d3.csv("stages_TDF.csv").then(function(data_) {
      
      data = data_;
      parse_data();
      country_stage_type_to_win_map = aggregateWinsPerStageType(data_);
      console.log(country_stage_type_to_win_map);
      x_y_arr = setUpAxisAndBars(height,width,svg);
      x = x_y_arr[0];
      y = x_y_arr[1];
      animation_runs = animation_runs + 1;

    // Animation
      animate(x,y,my_p,svg,height,tooltip);
    }).
    catch (function(error) {
      d3.select("#my_dataviz").html = "";    
      svg.selectAll("*").remove();
      x_y_arr = setUpAxisAndBars(height,width,svg);
      x = x_y_arr[0];
      y = x_y_arr[1];
    
    // Animation
      animate(x,y,my_p,svg,height,tooltip);
    })
  } else {
      svg.selectAll("*").remove();
      x_y_arr = setUpAxisAndBars(height,width,svg);
      x = x_y_arr[0];
      y = x_y_arr[1];
    // Animation
      animate(x,y,my_p,svg,height,tooltip);

  }
};

function draw_stacked_chart() {

    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 30, bottom: 20, left: 50},
        width = 1600 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;

    // append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
      .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")");

    // Parse the Data
    d3.csv("stages_TDF.csv").then(function(data) {

      // List of subgroups = header of the csv files = soil condition here
      var subgroups = get_unique_stage_types(data);
      //console.log(countByCountry);
      console.log(subgroups);
      // List of groups = species here = value of the first column called group -> I show them on the X axis
      var groups = d3.map(data, function(d){return(d.Type)}).keys()

      data.forEach(function(d){
	    //group and organize your data as needed here
      countByCountry = d3.nest()
      //set the decade as your key
      .key(function(d) {return d["Winner_Country"];})
      .key(function(d) {return d["Type"];})
      //rollup and sum your cat values by decade
      .rollup(d => d.length)
      .entries(data);
    });
    
    console.log(countByCountry);
      // Add X axis
    var x = d3.scaleBand()
          .domain(groups)
          .range([0, width])
          .padding([0.2])
    svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x).tickSizeOuter(0));

      // Add Y axis
    var y = d3.scaleLinear()
        .domain([0, 60])
        .range([ height, 0 ]);
      svg.append("g")
        .call(d3.axisLeft(y));

      // color palette = one color per subgroup
    var color = d3.scaleOrdinal()
        .domain(subgroups)
        .range(['#e41a1c','#377eb8','#4daf4a'])

      //stack the data? --> stack per subgroup
      var stackedData = d3.stack()
        .keys(subgroups)
        (data)

      // Show the bars
      svg.append("g")
        .selectAll("g")
        // Enter in the stack data = loop key per key = group per group
        .data(stackedData)
        .enter().append("g")
          .attr("fill", function(d) { return color(d.key); })
          .selectAll("rect")
          // enter a second time = loop subgroup per subgroup to add all rectangles
          .data(function(d) { return d; })
          .enter().append("rect")
            .attr("x", function(d) { return x(d.data.group); })
            .attr("y", function(d) { return y(d[1]); })
            .attr("height", function(d) { return y(d[0]) - y(d[1]); })
            .attr("width",x.bandwidth())
    })
};

</script>

</body>